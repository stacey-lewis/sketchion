{"version":3,"sources":["logo.svg","components/Sketch.js","components/Handpose.js","components/Home.js","App.js","reportWebVitals.js","index.js"],"names":["sketch","p5","cvs","video","drawSettings","fillColor","borderColor","brushSelected","loadingMessageSetter","drawVar","predictions","prevXPos","prevYPos","prevXPosThumb","prevYPosThumb","xIndex","yIndex","xThumb","yThumb","verticesX","verticesY","setWidth","windowWidth","setHeight","windowHeight","setup","colorMode","RGBA","options","flipHorizontal","maxContinuousChecks","Infinity","detectionConfidence","scoreThreshold","iouThreshold","createCanvas","createCapture","VIDEO","ml5","on","results","parent","hide","background","myCustomRedrawAccordingToNewPropsHandler","props","console","log","brushselected","setloadingmessage","fillcolourselected","rgbaFill","r","g","b","a","outlinecolourselected","rgbaBorder","draw","keyIsDown","drawKeyPoints","clear","keyIsPressed","key","saveImage","fill","strokeWeight","stroke","noStroke","drawIndexDots","drawIndexLine","noFill","drawIndexThumb","shadeIndexThumb","drawFromAllHandPoints","i","length","prediction","j","landmarks","keypoint","ellipse","indexFinger","map","size","Math","abs","line","insertVerticesPoint","floor","splice","beginShape","vertex","endShape","saveCanvas","Handpose","useState","setBrushSelected","loadingMessage","setLoadingMessage","fillColorSelected","setFillColorSelected","outlineColorSelected","setOutlineColorSelected","displayBackGroundColorPicker","setDisplayBackgroundColorPicker","displayBorderColorPicker","setDisplayBorderColorPicker","brushSelectorFunction","colourSelectorFunction","color","rgb","openColorButton","button","closeColorButton","id","className","onClick","src","alt","style","border","backgroundColor","onChangeComplete","Home","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.ac5f4a96.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/logo.6ce24c58.svg\";","import React from \"react\";\nimport * as p5 from \"p5\";\nimport * as ml5 from \"ml5\";\nimport \"./Handpose.css\";\n// import {ChromePicker} from 'react-color';\nimport P5Wrapper from 'react-p5-wrapper';\n\n\n  const sketch = (p5) => {\n\n    //updated from state variables\n    let drawSettings = {\n      fillColor: {},\n      borderColor: {},\n      brushSelected: 1,\n      loadingMessageSetter: null,\n    }; //drawSettings\n\n      //variables for setting positions\n    let drawVar = {\n      predictions: [],\n      prevXPos: 0,\n      prevYPos: 0,\n      prevXPosThumb: 0,\n      prevYPosThumb: 0,\n      xIndex: 0,\n      yIndex: 0,\n      xThumb: 0,\n      yThumb: 0,\n      verticesX: [],\n      verticesY: [],\n    }; //drawVar\n\n     let cvs;\n     let video;\n\n     //set default width for canvas\n     let setWidth = (p5.windowWidth - 340);\n     let setHeight = (p5.windowHeight);\n\n     let canvasSize = {};\n     // //capture hand keyPoints\n     // let drawVar.predictions = [];\n     // // let root = document.documentElement;\n     // //initialise shape-related draws\n     // let drawVar.prevXPos = 0;\n     // let drawVar.prevYPos = 0;\n     // let drawVar.prevXPosThumb = 0;\n     // let drawVar.prevYPosThumb = 0;\n     // let xIndex = 0;\n     // let drawVar.yIndex = 0;\n     // let drawVar.xThumb = 0;\n     // let drawVar.yThumb = 0;\n     // let drawVar.verticesX = [];\n     // let drawVar.verticesY = [];\n\n    p5.setup = () => {\n\n      p5.colorMode(p5.RGBA, 255);\n      //set options for initialising handpose\n       const options = {\n         flipHorizontal: true,\n         maxContinuousChecks: Infinity, // How many frames to go without running the bounding box detector. Defaults to infinity, but try a lower value if the detector is consistently producing bad drawVar.predictions.\n         detectionConfidence: 0.8, // Threshold for discarding a prediction. Defaults to 0.8.\n         scoreThreshold: 0.75, // A threshold for removing multiple (likely duplicate) detections based on a \"non-maximum suppression\" algorithm. Defaults to 0.75\n         iouThreshold: 0.3\n       }; //options\n\n       //create p5.canvas\n       cvs = p5.createCanvas(setWidth, setHeight);\n\n       //create video component, save into 'video'\n       // let constraints = {\n       //   video: {\n       //     mandatory: {\n       //       minWidth: setWidth,\n       //       minHeight: setHeight\n       //     },\n       //   //   optional: [{ maxFrameRate: 10 }]\n       // }, //video\n       //   // audio: true\n       // };\n\n       video = p5.createCapture(p5.VIDEO);\n\n        // call modelReady() when it is loaded\n      const handpose = ml5.handpose(video, options, ml5.modelReady);\n\n       // This sets up an event that fills the global variable \"drawVar.predictions\"\n       // with an array every time new hand poses are detected\n       handpose.on(\"predict\", results => {\n         drawVar.predictions = results;\n       });\n\n       //set canvas parent as 'handpose-canvas'\n       cvs.parent('handpose-canvas');\n\n       //set video parent as 'handpose-video-component'\n       video.parent('handpose-video-component');\n       // Hide the video element, and just show the canvas\n       video.hide();\n\n       //set background colour to white of canvas\n       p5.background(255);\n    }; //setup\n\n    //-----------------------WRAPPER ---------------------------\n    //This is called when props change - it notices the state variable that changes from Handpose.js and\n    p5.myCustomRedrawAccordingToNewPropsHandler = (props) => {\n      console.log('Custom Redraw!!!');\n      //if notice change to brush - update in local variable\n      if(props.brushselected) {\n        drawSettings.brushSelected = props.brushselected;\n      } //if\n\n      if(typeof props.setloadingmessage === \"function\") {\n\n        console.log('setloading message!', props.setloadingmessage);\n        drawSettings.loadingMessageSetter = props.setloadingmessage;\n      } //if\n\n      //if notice change to fill colour - update in local variable\n\n      if(props.fillcolourselected) {\n        let rgbaFill = `rgba(${props.fillcolourselected.r},${props.fillcolourselected.g},${props.fillcolourselected.b},${props.fillcolourselected.a})`;\n        drawSettings.fillColor = rgbaFill;\n\n      } // if\n      //if notice change to border colour - update in local variable\n      if(props.outlinecolourselected) {\n        let rgbaBorder = `rgba(${props.outlinecolourselected.r},${props.outlinecolourselected.g},${props.outlinecolourselected.b},${props.outlinecolourselected.a})`;\n        drawSettings.borderColor = rgbaBorder;\n\n      } // if\n    };\n    //-----------------------WRAPPER ---------------------------\n\n\n    ml5.modelReady = () => {\n      console.log(\"Model ready!\");\n      drawSettings.loadingMessageSetter(\"\");\n    }; //modelReady\n\n    p5.draw = () => {\n      //turn on webcam behind canvas\n      // p5.image(video, 0, 0, setWidth, setHeight);\n\n      //draw only if shift is held down\n      if (p5.keyIsDown(13)) {\n        drawKeyPoints();\n      } //if keyIsDown\n\n      //clear screen if down arrow pressed\n      if (p5.keyIsDown(40)){\n          p5.clear();\n          p5.background(255);\n          drawVar.prevXPos = 0;\n          drawVar.prevYPos = 0;\n          drawVar.prevXPosThumb = 0;\n          drawVar.prevYPosThumb = 0;\n          drawVar.xIndex = 0;\n          drawVar.yIndex = 0;\n          drawVar.xThumb = 0;\n          drawVar.yThumb = 0;\n          drawVar.verticesX = [];\n          drawVar.verticesY = [];\n      }; //if down arrow pushed clear screen and reset shapes\n\n      if(!p5.keyIsDown(13)) {\n        drawVar.prevXPos = 0;\n        drawVar.prevYPos = 0;\n        drawVar.prevXPosThumb = 0;\n        drawVar.prevYPosThumb = 0;\n        drawVar.xIndex = 0;\n        drawVar.yIndex = 0;\n        drawVar.xThumb = 0;\n        drawVar.yThumb = 0;\n        drawVar.verticesX = [];\n        drawVar.verticesY = [];\n        // p5.\n      }; //if SHIFT is not down\n\n      if (p5.keyIsPressed == true && p5.key === 's') {\n        saveImage();\n      } //save 's' shortcut\n\n\n        // p5.windowResized = () => {\n        //   console.log('windowresized');\n        //   // p5.resizeCanvas(setWidth, setHeight);\n        // }; //windowResized\n\n\n    }; //draw\n\n    const drawKeyPoints = () => {\n\n      //setUniversalFillColor\n      p5.fill(drawSettings.fillColor);\n      p5.strokeWeight(1); //set default line to 1.\n      p5.stroke(drawSettings.borderColor);\n\n      //check which brushSelector is selected.\n      if (drawSettings.brushSelected === 1){\n        p5.noStroke(); //turn off border\n        drawIndexDots();\n      }\n      else if (drawSettings.brushSelected === 2) {\n        p5.strokeWeight(1); //set default line to 1.\n        drawIndexLine();\n      }\n      else if (drawSettings.brushSelected === 3) {\n        p5.noFill(); //set default line to 1.\n        p5.strokeWeight(1); //set default line to 1.\n        drawIndexThumb();\n      }\n      else if (drawSettings.brushSelected === 4) {\n        p5.noStroke(); //turn off border\n        shadeIndexThumb(); //draw function\n      }\n      else if (drawSettings.brushSelected === 5) {\n\n        drawFromAllHandPoints();\n      }\n      else if (drawSettings.brushSelected === 6){\n        drawFromAllHandPoints();\n      } //end if drawSettings.brushSelected\n\n    }; //drawKeypoints\n\n    //---------------------DRAW FUNCTIONS --------------------\n\n    const drawFromAllHandPoints = () => {\n      // console.log('drawVar.predictions', drawVar.predictions);\n      for (let i = 0; i < drawVar.predictions.length; i += 1) {\n        const prediction = drawVar.predictions[i];\n        //loops through drawVar.predictions and maps each element in the array\n        for (let j = 0; j < prediction.landmarks.length; j += 1) {\n          //loops through each prediction landmark and then creates a cirle based on each one\n          const keypoint = prediction.landmarks[j];\n        p5.ellipse(keypoint[0], keypoint[1], 10, 10); //shape of draw.\n        } //for\n      } //for\n    }; //drawFromAllHandPoints\n\n    //Only draws from one point on the index finger\n    const drawIndexLine = () => {\n\n      for (let i = 0; i < drawVar.predictions.length; i += 1) {\n        const prediction = drawVar.predictions[i];\n        const indexFinger = prediction.landmarks[8];\n\n        drawVar.xIndex = p5.map(indexFinger[0],0,640,0,setWidth);\n        drawVar.yIndex = p5.map(indexFinger[1],0,480,0,setHeight);\n\n        if(drawVar.prevXPos != 0 && drawVar.prevYPos != 0) {\n\n          let size = 0;\n          if ( ((drawVar.xIndex - drawVar.prevXPos) + (drawVar.yIndex - drawVar.prevYPos) / 2 ) < 10 ) {\n            size = Math.abs(((drawVar.xIndex - drawVar.prevXPos) + (drawVar.yIndex - drawVar.prevYPos)) / 2);\n          } //if\n          else {\n            size = 2;\n          } //if else\n          p5.strokeWeight(size);\n          p5.line(drawVar.xIndex, drawVar.yIndex, drawVar.prevXPos, drawVar.prevYPos); //joins lines at top/bottom.\n        } //if - removes line from top left to starting position\n      } //for\n      drawVar.prevXPos = drawVar.xIndex;\n      drawVar.prevYPos = drawVar.yIndex;\n    }; //drawFromIndexFingerSharpLine\n\n    //circle drawing from indexFinger. Circle size increases with distance between x-\n    const drawIndexDots = () => {\n      for (let i = 0; i < drawVar.predictions.length; i += 1) {\n        const prediction = drawVar.predictions[i];\n        const indexFinger = prediction.landmarks[8];\n        drawVar.xIndex = p5.map(indexFinger[0],0,640,0,setWidth);\n        drawVar.yIndex = p5.map(indexFinger[1],0,480,0,setHeight);\n\n        if (drawVar.xIndex != 0 && drawVar.yIndex != 0) {\n          let size = 0;\n          if ( ((drawVar.xIndex - drawVar.prevXPos) + (drawVar.yIndex - drawVar.prevYPos) / 2 ) < 20 ) {\n            size = Math.abs(((drawVar.xIndex - drawVar.prevXPos) + (drawVar.yIndex - drawVar.prevYPos)) / 2);\n          } //if\n          else {\n            size = 20;\n          } //if else\n          p5.ellipse(drawVar.xIndex , drawVar.yIndex, size, size); //shape of draw.\n        } //if - remove line from top of screen\n        drawVar.prevXPos = drawVar.xIndex;\n        drawVar.prevYPos = drawVar.yIndex;\n\n      } //for\n    }; //drawFromIndexFingerDots\n\n    //line drawing from thumb to index finger.\n    const drawIndexThumb = () => {\n\n      for (let i = 0; i < drawVar.predictions.length; i += 1) {\n        const prediction = drawVar.predictions[i];\n\n        //GET INDEX POSITION - map to set to canvas size\n        const indexFinger = prediction.landmarks[8];\n        drawVar.xIndex = p5.map(indexFinger[0],0,640,0,setWidth);\n        drawVar.yIndex = p5.map(indexFinger[1],0,480,0,setHeight);\n\n        //GET THUMB POSITION - map to set to canvas size\n        const keypoint = prediction.landmarks[4];\n        drawVar.xThumb = p5.map(keypoint[0],0,640,0,setWidth);\n        drawVar.yThumb = p5.map(keypoint[1],0,480,0,setHeight);\n\n        //Draw lines - exclude if shift wasn't previously held down (to prevent auto-joining of drawn elements)\n        if(drawVar.prevXPos != 0 && drawVar.prevYPos != 0 && drawVar.prevXPosThumb != 0 && drawVar.prevYPosThumb != 0 && drawVar.xThumb != 0 && drawVar.yThumb != 0 && drawVar.xIndex != 0 && drawVar.yIndex != 0) {\n          p5.line(drawVar.xIndex, drawVar.yIndex, drawVar.prevXPos, drawVar.prevYPos);\n          p5.line(drawVar.xThumb, drawVar.yThumb, drawVar.prevXPos, drawVar.prevYPos);\n          p5.line(drawVar.xThumb, drawVar.yThumb, drawVar.prevXPosThumb, drawVar.prevYPosThumb); //joins lines at top/bottom of link\n        }  //if\n\n        //once mapped and drawn current position, set them as the previous positions\n        drawVar.prevXPosThumb = drawVar.xThumb;\n        drawVar.prevYPosThumb = drawVar.yThumb;\n        drawVar.prevXPos = drawVar.xIndex;\n        drawVar.prevYPos = drawVar.yIndex;\n      } //for\n    }; //drawIndexThumb\n\n    //shading from thumb to index finger.\n    const shadeIndexThumb = () => {\n\n      for (let i = 0; i < drawVar.predictions.length; i += 1) {\n        const prediction = drawVar.predictions[i];\n\n        //GET INDEX POSITION - map to set to canvas size\n        const indexFinger = prediction.landmarks[8];\n        drawVar.xIndex = p5.map(indexFinger[0],0,640,0,setWidth);\n        drawVar.yIndex = p5.map(indexFinger[1],0,480,0,setHeight);\n\n        //GET THUMB POSITION - map to set to canvas size\n        const keypoint = prediction.landmarks[4];\n        drawVar.xThumb = p5.map(keypoint[0],0,640,0,setWidth);\n        drawVar.yThumb = p5.map(keypoint[1],0,480,0,setHeight);\n\n        //set starting points for shape\n        if(drawVar.verticesX.length < 2 ) {\n          drawVar.verticesX = [drawVar.xIndex , drawVar.xThumb , drawVar.xIndex];\n          drawVar.verticesY = [drawVar.yIndex , drawVar.yThumb , drawVar.yIndex];\n        } else {\n          //determines the point to insert the new Index and Thumb x indices\n          const insertVerticesPoint = Math.floor(drawVar.verticesX.length / 2);\n          drawVar.verticesX.splice(insertVerticesPoint, 0, drawVar.xIndex);\n          drawVar.verticesX.splice(insertVerticesPoint, 0, drawVar.xThumb);\n          drawVar.verticesY.splice(insertVerticesPoint, 0, drawVar.yIndex);\n          drawVar.verticesY.splice(insertVerticesPoint, 0, drawVar.yThumb);\n\n          //create a new shape based on the points stored in the vertices array.\n          p5.beginShape();\n            for (let i = 0; i < drawVar.verticesX.length; i++) {\n              p5.vertex(drawVar.verticesX[i], drawVar.verticesY[i]);\n            }; //for\n            p5.endShape();\n          // p5.rect(drawVar.xIndex, drawVar.yIndex, rectWidth,44 rectHeight);\n        }  //if\n\n        //once drawn current, set that to the previous for the next draw.\n        drawVar.prevXPosThumb = drawVar.xThumb;\n        drawVar.prevYPosThumb = drawVar.yThumb;\n        drawVar.prevXPos = drawVar.xIndex;\n        drawVar.prevYPos = drawVar.yIndex;\n      } //for\n    }; //shadeIndexThumb\n\n\n    const saveImage = () =>\n       {p5.saveCanvas('sketchion-creation', 'png');\n     } //save option\n\n\n      //----------------------- TODO: Auto resize -----------------------------\n\n    // p5.windowResized = () => {\n    //   p5.resizeCanvas(setWidth, setHeight);\n    // }; //windowResized\n  // };\n\n\n  }; //sketch\n\n  export default sketch;\n","import React, { useEffect, useState} from \"react\";\nimport * as p5 from \"p5\";\nimport * as ml5 from \"ml5\";\nimport \"./Handpose.css\";\nimport {ChromePicker} from 'react-color';\nimport P5Wrapper from 'react-p5-wrapper';\nimport sketch from './Sketch';\n\n\nconst Handpose = (props) => {\n\n  //default set to line drawing\n  const [brushSelected, setBrushSelected] = useState(1);\n  const [loadingMessage, setLoadingMessage] = useState('loading ... ');\n  const [outlineWidthSelected, setOutlineWidthSelected] = useState(1);\n  const [fillColorSelected, setFillColorSelected] = useState({\n    r: 0,\n    g: 0,\n    b: 0,\n    a: 1\n  });\n  const [outlineColorSelected, setOutlineColorSelected] = useState({\n    r: 0,\n    g: 0,\n    b: 0,\n    a: 1\n  });\n  const [displayBackGroundColorPicker, setDisplayBackgroundColorPicker] = useState(false);\n  const [displayBorderColorPicker, setDisplayBorderColorPicker] = useState(false);\n  // const [windowSize, setWindowSize] = useState({\n  //     width: window.innerWidth,\n  //     height: window.innerHeight\n  //   }); //canvasSize state\n\n    // useEffect( () => {\n    //   if (windowSize.width != window.innerWidth || windowSize.height != window.innerHeight) {\n    //     console.log('updating windowsize!');\n    //     setWindowSize({width: window.innerWidth, height: window.innerHeight});\n    //   } //if\n    // },[]); //useEffect\n\n  //onClick update brush selector\n  const brushSelectorFunction = (i) => {\n    setBrushSelected(i);\n  }; //brushSelectorFunction\n\n  //onChange update colour selector\n  const colourSelectorFunction = (color, fill) => {\n    // console.log('fill', fillColorSelected);\n    if(fill) {\n      setFillColorSelected(color.rgb);\n      // console.log('fill - after set', fillColorSelected);\n    } else {\n      // console.log('outline', outlineColorSelected);\n      setOutlineColorSelected(color.rgb);\n      // console.log('outline - after set', outlineColorSelected);\n    }\n  }; //colorSelectorFunction\n\n\n  //onClick open background color selector\n  const openColorButton = (button) => {\n    if (button === 'background') {\n      setDisplayBackgroundColorPicker(!displayBackGroundColorPicker);\n    }; //if\n    if (button === 'border') {\n      setDisplayBorderColorPicker(!displayBorderColorPicker);\n    }; //if\n  }; //openColorBackgroundButton\n\n  //onClick open background color selector\n  const closeColorButton = (button) => {\n    if (button === 'background') {\n      setDisplayBackgroundColorPicker(false);\n    }; //\n    if (button === 'border') {\n      setDisplayBorderColorPicker(false);\n    }; //\n\n  }; //openColorBackgroundButton\n\n  return(\n     <>\n     <div id=\"handpose-component\">\n       <header className=\"header\">\n         <h1 className=\"logo\">sketchion.</h1>\n         <div id=\"handpose-controls\">\n           <p id=\"info\"><span className=\"logo\">sketchion</span> tracks your hand movement - enabling you to create expressive digital artworks.</p>\n           <hr />\n           <div className=\"detailed-instructions\">\n           <p>Simply enable webcam, hold down <code>ENTER</code> and start creating.</p>\n             <p>Hit <code>DOWN ARROW</code> to reset the canvas, & <code>s</code> to download canvas.</p> <br/>\n             {/* <p>Select a brush (<code>1</code> - <code>5</code>):</p> */}\n             <div className = \"grid-swatches\">\n               <img onClick={() => brushSelectorFunction(1)} src=\"dots.png\" alt=\"\" style={{border: brushSelected === 1 ? \"2pt solid rgb(185, 185, 185)\": \"2pt solid rgb(185, 185, 185, 0.15)\"}}/>\n               <img onClick={() => brushSelectorFunction(2)} src=\"line.png\" alt=\"\" style={{border: brushSelected === 2 ? \"2pt solid rgb(185, 185, 185)\": \"2pt solid rgb(185, 185, 185, 0.15)\"}}/>\n               <img onClick={() => brushSelectorFunction(3)} src=\"hash.png\" alt=\"\" style={{border: brushSelected === 3 ? \"2pt solid rgb(185, 185, 185)\": \"2pt solid rgb(185, 185, 185, 0.15)\"}}/>\n               <img onClick={() => brushSelectorFunction(4)} src=\"hash-fill.png\" alt=\"\" style={{border: brushSelected === 4 ? \"2pt solid rgb(185, 185, 185)\": \"2pt solid rgb(185, 185, 185, 0.15)\"}}/>\n               <img onClick={() => brushSelectorFunction(5)} src=\"hand.png\" alt=\"\" style={{border: brushSelected === 5 ? \"2pt solid rgb(185, 185, 185)\": \"2pt solid rgb(185, 185, 185, 0.15)\"}}/>\n            </div>\n            <div className=\"button1\">\n              <button className=\"colourButton\" onClick={() => openColorButton('background')}>fill colour\n                <div className='previewBackgroundColor' style={{backgroundColor: ` rgba(${fillColorSelected.r},${fillColorSelected.g},${fillColorSelected.b},${fillColorSelected.a})`, border: `2pt solid  rgba(${fillColorSelected.r},${fillColorSelected.g},${fillColorSelected.b},${fillColorSelected.a})`}}>\n\n                </div>\n              </button>\n              { displayBackGroundColorPicker ?\n                <div className='popover'>\n                  <div className='cover' onClick={() => closeColorButton('background')} ></div>\n                 <ChromePicker\n                    color={fillColorSelected} onChangeComplete={(color, fill) => colourSelectorFunction(color, fill=true) } />\n              </div> : null }\n            </div>\n\n            <div className=\"button2\">\n              <div>\n                <button className=\"colourButton\" onClick={() => openColorButton('border')}>\n                  border colour\n                  <div className='previewBorderColor' style={{border: `2pt solid rgba(${outlineColorSelected.r},${outlineColorSelected.g},${outlineColorSelected.b},${outlineColorSelected.a})`}}>\n                  </div>\n                </button>\n              </div>\n              { displayBorderColorPicker ?\n                <div className='popover'>\n                  <div className='cover' onClick={() => closeColorButton('border')} ></div>\n                  <ChromePicker\n                  color={outlineColorSelected} onChangeComplete={(color, fill) => colourSelectorFunction(color, fill=false) } />\n\n              </div> : null }\n            </div>\n            <div>\n\n            </div>\n          </div>\n          <p id='footer'>&copy; <span className=\"logo\">sketchion</span> -- stacey lewis 2021</p>\n        </div>\n       </header>\n      <div id=\"handpose-canvas\">\n        <div className=\"loadingmessage\">{loadingMessage} </div>\n        <P5Wrapper sketch={sketch} brushselected={brushSelected} outlinecolourselected={outlineColorSelected} fillcolourselected={fillColorSelected}\n        setloadingmessage={setLoadingMessage}\n        // windowsize={windowSize}\n      />\n      </div>\n      <div id=\"handpose-video-component\">\n        {/* WEBCAM HERE LATER ??? */}\n      </div>\n    </div>\n    </>\n   ); //return\n\n}; //Canvas\n\nexport default Handpose;\n","import React from 'react';\nimport Handpose from './Handpose';\n\nimport './Home.css';\n\nfunction Home() {\n  return (\n    <div className=\"home\">\n      <div>\n        <Handpose />\n      </div>\n\n    </div>\n  );\n}\n\nexport default Home;\n","import logo from './logo.svg';\n// import Canvas from './components/Canvas';\nimport Home from './components/Home';\n// import HandposeReactExample from './components/HandposeReactExample';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Home />\n      {/* <Canvas /> */}\n      {/* <App /> */}\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}